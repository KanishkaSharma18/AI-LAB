import re

# ---------- Utility Functions ----------

def is_variable(x):
    """Check if x is a variable (starts with lowercase)."""
    return isinstance(x, str) and x[0].islower()

def is_compound(x):
    """Check if x is a compound expression."""
    return isinstance(x, tuple)

def occur_check(var, expr):
    """Ensure a variable does not appear within its own substitution."""
    if var == expr:
        return True
    elif is_compound(expr):
        return any(occur_check(var, subexpr) for subexpr in expr[1])
    else:
        return False

def substitute(expr, subst):
    """Apply substitutions recursively."""
    if isinstance(expr, str):
        return subst.get(expr, expr)
    elif is_compound(expr):
        functor, args = expr
        return (functor, [substitute(arg, subst) for arg in args])
    else:
        return expr


# ---------- Unification Algorithm ----------

def unify(x, y, subst=None):
    """Unify two expressions and return the substitution dictionary."""
    if subst is None:
        subst = {}

    x = substitute(x, subst)
    y = substitute(y, subst)

    if x == y:
        return subst

    elif is_variable(x):
        if occur_check(x, y):
            return None
        subst[x] = y
        return subst

    elif is_variable(y):
        if occur_check(y, x):
            return None
        subst[y] = x
        return subst

    elif is_compound(x) and is_compound(y):
        if x[0] != y[0] or len(x[1]) != len(y[1]):
            return None
        for a, b in zip(x[1], y[1]):
            subst = unify(a, b, subst)
            if subst is None:
                return None
        return subst

    else:
        return None


# ---------- Parser for User Input ----------

def parse_expression(expr_str):
    """
    Converts string like 'P(x,h(y))' into tuple ('P', ['x', ('h', ['y'])])
    """
    expr_str = expr_str.strip()

    # Match predicate name and arguments
    match = re.match(r"([A-Za-z0-9_]+)\((.*)\)", expr_str)
    if not match:
        return expr_str  # It's a constant or variable

    functor = match.group(1)
    args_str = match.group(2)

    # Split arguments by commas considering nested parentheses
    args = []
    depth = 0
    current = ""
    for char in args_str:
        if char == ',' and depth == 0:
            args.append(parse_expression(current.strip()))
            current = ""
        else:
            if char == '(':
                depth += 1
            elif char == ')':
                depth -= 1
            current += char
    if current:
        args.append(parse_expression(current.strip()))

    return (functor, args)


# ---------- Main Application ----------

def logic_reasoning_app():
    print("\n=== LOGICAL REASONING UNIFICATION APP ===")
    print("Enter two logical expressions to check if they can be unified.")
    print("------------------------------------------")

    expr1_str = input("Enter first expression: ").strip()
    expr2_str = input("Enter second expression: ").strip()

    expr1 = parse_expression(expr1_str)
    expr2 = parse_expression(expr2_str)

    print("\nParsed Expression 1:", expr1)
    print("Parsed Expression 2:", expr2)

    result = unify(expr1, expr2)

    print("\n=== RESULT ===")
    if result:
        print("✅ Unification Successful!")
        print("Substitution Set:")
        for var, val in result.items():
            print(f"  {var} = {val}")
    else:
        print("❌ Unification Failed.")


# ---------- Run the App ----------

if __name__ == "__main__":
    logic_reasoning_app()
